// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.13;

import "forge-std/Test.sol";
import {ButtonswapPair} from "src/ButtonswapPair.sol";
import {Math} from "src/libraries/Math.sol";
import {MockERC20} from "mock-contracts/MockERC20.sol";
import {MockRebasingERC20} from "mock-contracts/MockRebasingERC20.sol";
import {MockUFragments} from "mock-contracts/MockUFragments.sol";
import {ICommonMockRebasingERC20} from "mock-contracts/interfaces/ICommonMockRebasingERC20/ICommonMockRebasingERC20.sol";
import {MockButtonswapFactory} from "test/mocks/MockButtonswapFactory.sol";

contract ExploitsTest is Test {
    struct TestVariables {
        address zeroAddress;
        address feeToSetter;
        address feeTo;
        address minter1;
        address minter2;
        address swapper1;
        address swapper2;
        address receiver;
        address burner1;
        address burner2;
        address exploiter;
        MockButtonswapFactory factory;
        ButtonswapPair pair;
        MockERC20 token0;
        MockERC20 token1;
        ICommonMockRebasingERC20 rebasingToken0;
        ICommonMockRebasingERC20 rebasingToken1;
        uint256 amount0In;
        uint256 amount1In;
        uint256 amount0Out;
        uint256 amount1Out;
        uint256 liquidity1;
        uint256 liquidity2;
        uint256 pool0;
        uint256 pool1;
        uint256 reservoir0;
        uint256 reservoir1;
    }

    MockERC20 public tokenA;
    MockERC20 public tokenB;
    ICommonMockRebasingERC20 public rebasingTokenA;
    ICommonMockRebasingERC20 public rebasingTokenB;
    address public userA = 0x000000000000000000000000000000000000000A;
    address public userB = 0x000000000000000000000000000000000000000b;
    address public userC = 0x000000000000000000000000000000000000000C;
    address public userD = 0x000000000000000000000000000000000000000d;
    address public userE = 0x000000000000000000000000000000000000000E;

    function setUp() public {
        tokenA = new MockERC20("TokenA", "TKNA");
        tokenB = new MockERC20("TokenB", "TKNB");
        // rebasingTokenA = ICommonMockRebasingERC20(address(MockRebasingERC20("TokenA", "TKNA", 18)));
        // rebasingTokenB = ICommonMockRebasingERC20(address(new MockRebasingERC20("TokenB", "TKNB", 18)));
        rebasingTokenA = ICommonMockRebasingERC20(address(new MockUFragments()));
        rebasingTokenB = ICommonMockRebasingERC20(address(new MockUFragments()));
        rebasingTokenA.initialize();
        rebasingTokenB.initialize();
    }

    function test_exploit_CanMintUsingUnaccountedSurplusIfSyncNotCalled(
        uint256 amount00,
        uint256 amount01,
        uint256 rebaseNumerator,
        uint256 rebaseDenominator
    ) public {
        // Make sure the amounts aren't liable to overflow 2**112
        // Divide by 4 so that it can handle a second mint
        // Divide by 1000 so that it can handle a rebase
        vm.assume(amount00 < (uint256(2 ** 112) / (4 * 1000)));
        vm.assume(amount01 < (uint256(2 ** 112) / (4 * 1000)));
        // Amounts must be non-zero
        // They must also be sufficient for equivalent liquidity to exceed the MINIMUM_LIQUIDITY
        vm.assume(Math.sqrt(amount00 * amount01) > 1000);
        // Keep rebase factor in sensible range
        vm.assume(rebaseNumerator > 0 && rebaseNumerator < 1000);
        vm.assume(rebaseDenominator > 0 && rebaseDenominator < 1000);
        // Requires positive rebase
        vm.assume(rebaseNumerator >  rebaseDenominator );

        TestVariables memory vars;
        vars.feeToSetter = userA;
        vars.feeTo = userB;
        vars.minter1 = userC;
        vars.exploiter = userD;
        vars.factory = new MockButtonswapFactory(vars.feeToSetter);
        vm.prank(vars.feeToSetter);
        vars.factory.setFeeTo(vars.feeTo);
        vars.pair = ButtonswapPair(vars.factory.createPair(address(rebasingTokenA), address(tokenB)));
        vars.rebasingToken0 = ICommonMockRebasingERC20(vars.pair.token0());
        vars.token1 = MockERC20(vars.pair.token1());
        vm.assume(amount00 < vars.rebasingToken0.mintableBalance());
        vars.rebasingToken0.mint(vars.minter1, amount00);
        vars.token1.mint(vars.minter1, amount01);

        // Mint initial liquidity
        vm.startPrank(vars.minter1);
        vars.rebasingToken0.transfer(address(vars.pair), amount00);
        vars.token1.transfer(address(vars.pair), amount01);
        vars.liquidity1 = vars.pair.mint(vars.minter1);
        vm.stopPrank();

        // Rebase
        vars.rebasingToken0.applyMultiplier(rebaseNumerator, rebaseDenominator);
        // Sync to make a reservoir have non-zero value
        vars.pair.sync();
        // Rebase again
        vars.rebasingToken0.applyMultiplier(rebaseNumerator, rebaseDenominator);
        // Don't call sync this time

        (vars.pool0, vars.pool1,) = vars.pair.getPools();
        (vars.reservoir0, vars.reservoir1) = vars.pair.getReservoirs();
        // Calculate how much the unaccounted surplus is
        uint256 amount10 = vars.rebasingToken0.balanceOf(address(vars.pair)) - vars.pool0 - vars.reservoir0;
        // Calculate the amount of the other token required to mint liquidity against the surplus amount
        uint256 amount11 = (amount10 * vars.pool1) / vars.pool0;
        // Mint the exploiter this token amount
        vm.assume(amount11 < vars.token1.mintableBalance());
        vars.token1.mint(vars.exploiter, amount11);

        // Save off exploiter token holdings value in terms of 0
        uint256 originalExploiterHoldingsInTermsOf0 = vars.rebasingToken0.balanceOf(vars.exploiter);
        originalExploiterHoldingsInTermsOf0+= (vars.token1.balanceOf(vars.exploiter)*vars.pool0)/vars.pool1;

        // Exploiter mints using unaccounted surplus
        vm.startPrank(vars.exploiter);
        // Despite being a dual sided mint we only transfer in one token to match the unaccounted rebase surplus
        vars.token1.transfer(address(vars.pair), amount11);
        vars.liquidity2 = vars.pair.mint(vars.exploiter);
        vm.stopPrank();

        // Exploiter burns liquidity
        vm.startPrank(vars.exploiter);
        // Exploiter sends back the liquidity tokens it just minted
        vars.pair.transfer(address(vars.pair), vars.pair.balanceOf(vars.exploiter));
        vars.pair.burn(vars.exploiter);
        vm.stopPrank();

        // Calculate new exploiter token holdings value in terms of 0
        (vars.pool0, vars.pool1,) = vars.pair.getPools();
        uint256 newExploiterHoldingsInTermsOf0 = vars.rebasingToken0.balanceOf(vars.exploiter);
        newExploiterHoldingsInTermsOf0+= (vars.token1.balanceOf(vars.exploiter)*vars.pool0)/vars.pool1;

        // If there was no exploit the exploiter would have not gained value during this
        assertLe(newExploiterHoldingsInTermsOf0, originalExploiterHoldingsInTermsOf0, "Exploiter has not gained value");
    }
}
